# 实践笔记

## 开发篇

### sql

#### 常用函数整理

```sql
--字符串处理
substr(a.area,1,2)=b.soapcode --截取前两位
--数字处理
avg(t.fscreen_res_times) --求平均
sum(t.fscreen_res_times) --求和
round(avg(t.fscreen_res_times),2) --保留两位小数
```

#### 判断是否为空

```sql
exch is null 
```
#### case语句加正则匹配所有数字

```sql
case
	when REGEXP_LIKE(netcartrate,'(^[+-]?\d{0,}\.?\d{0,}$)') then
		netcartrate || 'M'
	else
		netcartrate
	end 
		netcartrate

--简单Case函数
CASE sex
WHEN '1' THEN '男'
WHEN '2' THEN '女'
ELSE '其他' END
--Case搜索函数
CASE WHEN sex = '1' THEN '男'
WHEN sex = '2' THEN '女'
ELSE '其他' END
--正则表达式
^ 匹配输入字符串的开始位置
[+-] 匹配指定范围内的任意字符
? 匹配0或1个正好在它之前的那个字符
\d 匹配一个数字字符
{n,} n是一个非负整数。至少匹配前面的n次
$ 匹配输入字符串的结束位置
```
#### update更新语句

```sql
UPDATE temp_userid t
SET t.ctime = (
		SELECT max(b.btime)
		FROM vi_speed_info b
		WHERE b.userid = t.userid
		)
--MAX 函数返回一列中的最大值
```
#### OVER()函数

```sql
UPDATE test_for_search t
SET (
		t.stime
		,t.responserate
		) = (
		SELECT a.stime,a.responserate
		FROM (
			SELECT userid,responserate,stime
			FROM (
				SELECT b.userid
					,b.responserate
					,b.stime
					,row_number() OVER (PARTITION BY b.userid ORDER BY b.stime) AS ind
				FROM v_speed_info_bday b
					,test_for_search t
				WHERE b.userid = t.userid
					AND b.stime BETWEEN to_date('2016-03-10 000000', 'yyyy-mm-dd hh24miss')
						AND to_date('2016-03-10 235959', 'yyyy-mm-dd hh24miss')
				GROUP BY b.userid,b.responserate,b.stime
				)
			WHERE ind = 1
			) a
		WHERE a.userid = t.userid
		)
--分析函数OVER(PARTITION BY)
ROW_NUMBER()返回结果集分区内行的序列号，每个分区的第一行从 1 开始

select decode(grouping(http_url), 1, '综合平均', http_url) http_url,
       avg(t.fscreen_res_times),
       avg(t.homepage_res_times),
       avg(t.homepage_dw_speed),
       avg(t.tcp_delay_times),
       avg(t.http_delay_times),
       avg(t.dns_delay_times),
       avg(t.access_succ_rate),
       avg(t.qoe_value)
  from app_qoe_http_info t
 where stime between to_date('2015-12-03 000000', 'yyyy-mm-dd hh24miss') and
       to_date('2015-12-03 171717', 'yyyy-mm-dd hh24miss')
   and t.band_width in
       (select rate_id from nettype_info where bandrate = '100M')
   and substr(t.citycd, 0, 2) = '08'
 group by rollup(http_url)

--聚合函数
--AVG	返回指定组中的平均值，空值被忽略
select  prd_no,avg(qty) from sales group by prd_no

--COUNT	返回指定组中项目的数量
select  count(prd_no) from sales

--COUNT_BIG  返回指定组中的项目数量，与COUNT函数不同的是COUNT_BIG返回bigint值，而COUNT返回的是int值
select  count_big(prd_no) from sales

--MAX	返回指定数据的最大值
select  prd_no,max(qty) from sales group by prd_no

--MIN  	返回指定数据的最小值
select  prd_no,min(qty) from sales group by prd_no

--SUM  	返回指定数据的和，只能用于数字列，空值被忽略
select  prd_no,sum(qty) from sales group by prd_no

--GROUPING  产生一个附加的列，当用CUBE或ROLLUP运算符添加行时，输出值为1.当所添加的行不是由CUBE或ROLLUP产生时，输出值为0
select  prd_no,sum(qty),grouping(prd_no) from sales group by prd_no with rollup

/*BINARY_CHECKSUM  返回对表中的行或表达式列表计算的二进制校验值，用于检测表中行的更改
CHECKSUM_AGG  返回指定数据的校验值，空值被忽略
CHECKSUM  返回在表的行上或在表达式列表上计算的校验值，用于生成哈希索引
STDEV  返回给定表达式中所有值的统计标准偏差
STDEVP  返回给定表达式中的所有值的填充统计标准偏差
VAR  返回给定表达式中所有值的统计方差
VARP  返回给定表达式中所有值的填充的统计方差*/

--ROLLUP()和CUBE()区别
--ROLLUP()生成简单的 GROUP BY 聚合行以及小计行或超聚合行，还生成一个总计行。
SELECT a, b, c, SUM ( <expression> )
FROM T
GROUP BY ROLLUP (a,b,c)
--会为 (a, b, c)、 (a, b) 和 (a) 值的每个唯一组合生成一个带有小计的行,还将计算一个总计行
--CUBE()生成简单的 GROUP BY 聚合行、ROLLUP 超聚合行和交叉表格行
SELECT a, b, c, SUM (<expression>)
FROM T
GROUP BY CUBE (a,b,c)
--会为 (a, b, c)、 (a, b)、 (a, c)、 (b, c)、 (a)、 (b) 和 (c) 值的每个唯一组合生成一个带有小计的行，还会生成一个总计行
```
#### 增加外键

作用是:最直观的作用是**防止非法数据录入**，就是说录入外键数据时必须在它所属的主表中存在相应数据，如果录入空字符或其他数据会报错。从软件工程的角度看，建立数据库的过程，是从建立物理模型开始的。在物理模型中创建了外键，那么在转化成概念模型甚至于生成sql代码时，就会自动生成相应字段，而不用重复定义。

```sql
create table dept	--公司的部门信息
(deptno number(10) not null,
deptname varchar2(30) not null,
constraint pk_dept primary key(deptno));	--主键

create table emp	--员工的基本信息
( empno number(10) not null,
fname varchar2(20) ,
lname varchar2(20) ,
dept number(10) ,
constraint pk_emp primary key(empno));  --主键

--在员工表增加外键关联到部门表,同时增加级联删除(on delete cascade这句话不加也可以)
alter table emp
add constraint fk_emp_dept foreign key(dept) references dept(deptno) on delete cascade;

delete from dept where deptno = 1;
--删除dept中的一条数据，emp中两条数据也被删除了
```
#### 字符串相加

```sql
cpuusage || '%' cpuusage,
```

#### nvl和nvl2函数

NVL( string1, replace_with) 功能：如果string1为NULL，则NVL函数返回replace_with的值，否则返回string1的值，如果两个参数都为NULL ，则返回NULL。

NVL2(expr1,expr2,expr3) 功能：如果参数表达式expr1值为NULL，则NVL2()函数返回参数表达式expr3的值；如果参数表达式expr1值不为NULL，则NVL2()函数返回参数表达式expr2的值。


```sql
nvl2(cpuusage,cpuusage || '%', 0) cpuusage,
```

#### between

```sql
between to_date('2015-09-23 000000','yyyy-mm-dd hh24miss') 
	and to_date('2015-09-23 175959','yyyy-mm-dd hh24miss')
```

#### decode

将查询结果翻译成其他值

```sql
decode(条件,值1,翻译值1,值2,翻译值2,...值n,翻译值n,缺省值)
```

#### 将表结构导出到word

```sql
SELECT t1.Table_Name AS "表名称",
t3.comments AS "表说明", 
t1.Column_Name AS "字段名称",
t1.Data_Type AS "数据类型",
t1.Data_Length AS "长度",
t1.NullAble AS "是否为空",
t2.Comments AS "字段说明",
t1.Data_Default "默认值"
FROM cols t1 left join user_col_comments t2
on t1.Table_name=t2.Table_name and t1.Column_Name=t2.Column_Name
left join user_tab_comments t3 
on t1.Table_name=t3.Table_name 
WHERE NOT EXISTS ( SELECT t4.Object_Name FROM User_objects t4
WHERE t4.Object_Type='TABLE' 
AND t4.Temporary='Y' 
AND t4.Object_Name=t1.Table_Name )
ORDER BY t1.Table_Name, t1.Column_ID;
```

#### 修改表字段varchar长度

```sql
oracle下这么执行
alter table member modify phone char(15);
sqlserver下这么执行
alter table member alter column phone char(15);
```

#### exists,in用法

> in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。
>
> Exists是存在判断，只要有其中一个存在就返回。in是返回所有包含在in中的数据。
>
>  exists 与 in 最大的区别在于 in引导的子句只能返回一个字段
>
> 强调的是是否返回结果集，不要求知道返回什么

#### START WITH CONNECT BY PRIOR子句实现递归查询

> prior 后面跟着的列代表的是本条记录中的列

![https://raw.githubusercontent.com/jayypc/notes/master/images/sql1.png]()

![https://raw.githubusercontent.com/jayypc/notes/master/images/sql2.png]()

### java

#### 打印数组

```java
Arrays.toString(arr);
//利用这个方法可以打印List
List a = new ArrayList<>();
Arrays.toString(a.toArray());
```

#### 判断是否是数字的正则表达式

```java
public static boolean isNumeric(String tester) {
        boolean isNumeric=false;
        if(Validators.isNotnull(tester) && Pattern.matches("^(-)?\\d+$", tester)) {
            isNumeric = true;
        }
        return isNumeric;
}
/*
^  代表第一个位置
(-)代表负号, 要匹配圆括号字符，请使用“\(”或“\)”
?  前面的也就是(-)出现零次或者一次
\  在java中代表转义字符,所以要得到正则表达式的\d(代表一个数字),需要\\才能够得到\,然后加个d
+  代表前面的表达式即\d可以出现一次或者多次
$  代表最后一个位置
*/
```

#### Hibernate

**getSession()**

- getSession()只要继承 sessionFactory
- getSession()方法，spring会把最原始的session给你，在使用完之后必须自己调用相应的close方法，而且也不会对声明式事务进行相应的管理，一旦没有及时关闭连接，就会导致数据库连接池的连接数溢出

**getHibernateTemplate()**

- getHibernateTemplate()方法必须继承HibernateDaoSupport

- getHibernateTemplate()方法是经过spring封装的，例如添加相应的声明式事务管理，由spring管理相应的连接。

- HibernateTemplate 提供非常多的常用方法来完成基本的操作，比如通常的增加、删除、修改、查询等操作

  - q void delete(Object entity)：删除指定持久化实例 
  - q deleteAll(Collection entities)：删除集合内全部持久化类实例 
  - q find(String queryString)：根据HQL查询字符串来返回实例集合 
  - q findByNamedQuery(String queryName)：根据命名查询返回实例集合 
  - q get(Class entityClass, Serializable id)：根据主键加载特定持久化类的实例 
  - q save(Object entity)：保存新的实例 
  - q saveOrUpdate(Object entity)：根据实例状态，选择保存或者更新 
  - q update(Object entity)：更新实例的状态，要求entity是持久状态 
  - q setMaxResults(int maxResults)：设置分页的大小

- 有些方法在getHibernateTemplate()并没有提供，这时我们用HibernateCallback 回调的方法管理数据库

  ```java
  //execute是最基础的
  //<Object> Object HibernateTemplate.execute(HibernateCallback<Object> action) throws DataAccessException
  public VulScannerInfo getScannerInfoByScannerId(final Long scannerId) {
    return (VulScannerInfo) getHibernateTemplate().execute(new HibernateCallback<Object>(){
      public Object doInHibernate(Session session)
        throws HibernateException, SQLException {

        //扫描器ID为空，则返回空
        if(scannerId == null){
          return null;
        }

        String hql = "from VulScannerInfo where scannerid = :scannerid and deleted = 0";
  	  //使用hql调用createQuery()方法
        Query query = session.createQuery(hql);
        query.setParameter("scannerid", scannerId);
  	  //确定返回的实例只有一个或者null时 用uniqueResult()方法
        return query.uniqueResult();
      }

    });
  }

  //excuteFind就是execute的结果集判断了一下:HibernateCallback 类型的action必须返回list
  public List<VulRiskTaskResultDetail> getVulTaskResultDetails(final FilterChain chain) {
    return getHibernateTemplate().executeFind(new HibernateCallback<Object>(){
      public Object doInHibernate(Session session) throws HibernateException, SQLException {

        String sql = "select  distinct {t.*} from vul_risk_task_result_detail t ";
        sql += "left join vul_risk_task_detail_history history on history.detailid = t.detailid ";
        if(chain != null){
          sql += chain.toSql();
        }
        //使用sql调用createSQLQuery()方法
        SQLQuery query = session.createSQLQuery(sql);
        setQueryParameter(query, chain);
        query.addEntity("t",VulRiskTaskResultDetail.class);
  	  //查询返回多个值用list()方法
        return query.list();
      }

    });
  }

  //或者使用?来做占位符
  public void paySuccess(Long orderNo) {
    String sql = "update Order  set  status =1  ,  payTime =?  where orderNo =? ";
    getCurrentSession().createQuery(sql).setTimestamp(0 ,new Date()).setLong(1, orderNo).executeUpdate();
  }

  //in语句中可以使用setParameterList()方法
  public Integer updateStatusDiscard(List<Long> rids) {
    String sql = "UPDATE requirement r SET r.status=0,r.updateTime=NOW() WHERE r.id IN (:rids)";
    return getCurrentSession().createSQLQuery(sql).setParameterList("rids", rids).executeUpdate();
  }
  ```

#### struts1的转发

```java
//1.页面
href="transfer.do"
//2.struts-config.xml
<action input="/index.jsp" path="/transfer" scope="request"
			type="org.springframework.web.struts.DelegatingActionProxy">
			 <forward name="main" path="/WEB-INF/MyJsp.jsp" />
</action>
//3.java文件
//返回MyJsp.jsp
return mapping.findForward("main");
//返回index.jsp
return mapping.getInputForward()
```

#### 时间处理

```java
//当前时间
Calendar calendar = Calendar.getInstance();
Date now = new Date();
//互相转换
calendar.setTime(now);
now = calendar.getTime();
//时间与字符串
SimpleDateFormat sf = new SimpleDateFormat("yyyyMMdd");
String date = sf.format(new Date());

String year = calendar.get(Calendar.YEAR);
String month = calendar.get(Calendar.MONTH)+1; //get的返回值为int
String day = calendar.get(Calendar.DATE);
String weekday = calendar.get(Calendar.DAY_OF_WEEK);//可以设置从哪一天开始 默认星期日 返回1~7
//时间变化
calendar.add( Calendar.MONTH,  +1 ) ;
calendar.add( Calendar.MONTH,  -1 ) ;
//设置周一
calendar.setFirstDayOfWeek(Calendar.MONDAY);
```

#### 输出printStackTrace()堆栈信息

- 简单办法，需要用到log4j

```java
log.error(e.getMessage(),e); 
```

- 通用办法，使用printStackTrace()的另一个构造方法

```java
StringWriter sw = new StringWriter();
e.printStackTrace(new PrintWriter(sw, true));
String str = sw.toString();
logger.error ( "Exception : " + str ) ;
```

#### XML解析与构造

```java
//解析
Element element;  
element.asXML(); //result:<info><Account>33</Account><CityCd>44</CityCd></info>
if(element != null){
  if(element.selectSingleNode("Account") != null){
    account = element.selectSingleNode("Account").getText();
  }
  if(element.selectSingleNode("CityCd") != null){
    cityCd = element.selectSingleNode("CityCd").getText();
  }
}

Element paramElement;   //<Account>33</Account> 仅有一个节点
paramElement.getText(); //result: 33

//构造
Element result = root.addElement("result");
result.setText("1");
```

#### try catch finally

- 即使catch里面有return也会执行finally
- 一般finally写的代码都是流关闭语句
- 如果没有执行try语句之前就return了或者发生异常，则不会进入finally

#### session

- request.setAttribute(position, nameOfObj)不同页面间传值使用时，只会从a.jsp到b.jsp一次传递，之后这个request就会失去它的作用范围
- session.setAttribute()会在一个过程中始终保有这个值。

```java
public LoginResult check(CheckInfo checkInfo,HttpServletRequest request){
    HttpSession session = request.getSession();
    session.setAttribute("loginUser", sysUser);
}

public String getStructure(HttpServletRequest request, Map<String, Object> map) {
    HttpSession session = request.getSession();
    sysUser = (SysUser) request.getAttribute("loginUser");
}
```

#### fastjson

- 前端数据格式为json，且后端使用fastJson的时候可以使用反序列注解，对实体类的时间格式进行格式化

```java
@JSONField (format="yyyy-MM-dd HH:mm:ss")  
private Date ctime;
```

### linux

#### netstat

用于显示各种网络相关信息

-a (all)显示所有选项，默认不显示LISTEN相关
-t (tcp)仅显示tcp相关选项
-u (udp)仅显示udp相关选项
-n 拒绝显示别名，能显示数字的全部转化成数字。
-l 仅列出有在 Listen (监听) 的服務状态

#### grep

正则匹配命令

-I(i大写) ：忽略大小写 
-c ：打印匹配的行数 
-l ：从多个文件中查找包含匹配项 
-v ：查找不包含匹配项的行 
-n：打印包含匹配项的行和行标
-A ：显示匹配行的后几行 
-B ：显示匹配行的前几行
-C ：显示匹配行的后前几行


```shell
#显示所有以d开头的文件中包含test的行。
$ grep 'test' d*
#显示在aa，bb，cc文件中匹配test的行。
$ grep 'test' aa bb cc
#显示所有包含每个字符串至少有5个连续小写字符的字符串的行。
$ grep '[a-z]\{5\}' aa

#在event.log中查找包含test内容及其后两行
more event.log|grep 'test' -A 2
```

#### wc

-c 统计字节数。
-l 统计行数。
-m 统计字符数。这个标志不能与 -c 标志一起使用。
-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。
-L 打印最长行的长度。

#### 查询某端口监听数量（运用上述三条命令）

```shell
netstat -na|grep 80|wc -l
查询80端口的监听数目
```
#### crontab

-e 编辑crontab服务文件

```
30 2 * * * /DATA1/script/auto.sh
05 22 * * * /usr/sbin/ntpdate 10.142.80.17;

cron文件语法:

分     小时    日       月       星期     命令
0-59   0-23   1-31   1-12     0-6     command     (取值范围,0表示周日一般一行对应一个任务)
记住几个特殊符号的含义:
“*”代表取值范围内的数字,
“/”代表”每”,
“-”代表从某个数字到某个数字,
“,”分开几个离散的数字
```

 -l  列出当前的所有调度任务

 -r  删除所有任务调度工作

查看服务是否已经运行用 ps -ax | grep cron 

#### ntpdate

当Linux服务器的时间不对的时候，可以使用ntpdate工具来校正时间。

```sql
05 22 * * * /usr/sbin/ntpdate 10.142.80.17;
```

#### vi清空

首先，使用gg调整光标到首行，然后使用dG命令即可。

#### df磁盘空间

-a 全部文件系统列表
-h 方便阅读方式显示
-H 等于“-h”，但是计算式，1K=1000，而不是1K=1024
-i 显示inode信息
-k 区块为1024字节
-l 只显示本地文件系统
-m 区块为1048576字节
--no-sync 忽略 sync 命令
-P 输出格式为POSIX
--sync 在取得磁盘信息前，先执行sync命令
-T 文件系统类型

```shell
df -hl 查看本地磁盘剩余空间
df -t ext3 指定磁盘类型
```

#### du目录或文件

-h：以人类可读的方式显示
-a：显示目录占用的磁盘空间大小，还要显示其下目录和文件占用磁盘空间的大小
-s：显示目录占用的磁盘空间大小，不要显示其下子目录和文件占用的磁盘空间大小
-c：显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和
--apparent-size：显示目录或文件自身的大小
-l ：统计硬链接占用磁盘空间的大小
-L：统计符号链接所指向的文件占用的磁盘空间大小

```shell
du -h 文件 
du -ah
du -sh
```

#### more

功能等同cat，只是带有翻页功能，还支持转跳行

按**空白键（space）**就往下一页显示，按 **b** 键就会往回（back）一页显示

```shell
more +3 test.log  #从第三行开始显示日志内容
more -4 test.log  #定义每次翻页4行
```

more, less 都具备查找功能，按/ 然后输入要找的字串，再按 Enter 即可，按 n(next) 会继续找，大写的 N 则是往回(上)找，按 q(quit)或者ZZ离开

#### find命令

```shell
#当前目录查找test文件
find -name test 
#全部目录中查找test文件
find / -name test
```

#### 解压缩

```shell
#zip
zip test.zip testinfo 	#将testinfo压缩成test.zip
unzip test.zip 			#将test.zip解压
#rar linux下不一定能解压rar需要安装有rarlinux
unrar x testl.rar 		#将test.rar解压，x代表解压所有路径
#tar.gz
tar –zvxf test.tar.gz	#将test.tar.gz解压

x : 从 tar 包中把文件提取出来
z : 表示 tar 包是被 gzip 压缩过的，所以解压时需要用 gunzip 解压
v : 显示详细信息
f xxx.tar.gz :  指定被处理的文件是 xxx.tar.gz
```

#### nohup

```shell
nohup your_command > nohup`date +%Y-%m-%d`.out 2>&1 &
```

### oracle

#### 登陆

- `sqlplus` 后输入账号密码

- 普通登陆: `sqlplus scott/123456`  或  `SQL>connect scott/123456`

- os身份登陆:`sqlplus / as sysdba `  或  `SQL>connect / as sysdba`

- 管理员登陆:`sqlplus sys/123456 as sysdba` 或 `SQL>connect sys/123456 as sysdba`

  > 普通的OS验证策略两个特点：一个是服务器本地生效，客户端匿名登录无效。另一个只能登录为管理员sys，不能其他用户。

#### 切换用户

- `connect hr/123456`

#### 创建用户,授权

- `create user 用户名 identified by 密码 default tablespace 表空间; ` 

- ```sql
  grant create session to 用户名;  	--授予用户创建session的权限，即登陆权限
  grant create table to 用户名;   	--授予创建表的权限
  grant insert table to 用户名;    	--插入表的权限
  grant update table to 用户名;    	--修改表的权限
  grant create tablespace to 用户名; --授予用户创建表空间的权限
  grant unlimited tablespace to 用户名;--授予用户使用表空间的权限
  grant create view to 用户名;  		--授予用户创建视图的权限
  grant DBA to 用户名;	   --授予DBA

  grant all privileges to public或用户名;	   --授予public(所有用户)或某用户所有权限
  ```

####  创建用户表空间

```sql
create tablespace 表空间名  
datafile ' 路径(要先建好路径)\***.dbf' size *M  
autoextend on  --自动增长  
--还有一些定义大小的命令，看需要 
 default storage(  
 initial 100K,  
 next 100k,  
);  

--例子
create tablespace DEMOSPACE   
datafile 'E:/oracle_tablespaces/DEMOSPACE_TBSPACE.dbf'   
size 1500M   
autoextend on next 5M maxsize 3000M;  

--一般建N个存数据的用户表空间和一个索引表空间
这个索引表空间和用户表空间在物理上没有区别,只是功能划分上的使用,如果是两个硬盘以上,将两个表空间建立在不同硬盘,提高IO效率.
对于一个频繁访问的表,其索引也是频繁访问的,其表和索引同时访问概率较大,为避免wr数据与wr索引之间的竞争可能,把不同的表数据和索引放在不同的表空间中,避免IO竞争.
```

#### 删除表空间

`drop tablespace tablespace_name including contents and datafiles`

#### 删除用户

`drop user user_name cascade`

#### 查询基础信息

​	**查询实例:** `show parameter instance`

​	**查询表空间:** ` select tablespace_name from dba_tablespaces;`

​	**查询当前用户被授予角色:** `select * from user_role_privs` 

​	**查询某用户下所有表及其占用空间:**

```sql
select SEGMENT_NAME, TABLESPACE_NAME, sum(BYTES / 1024 / 1024) || 'M'
  from USER_extents
 where SEGMENT_TYPE = 'TABLE'
 group by SEGMENT_NAME, TABLESPACE_NAME
```

​	**查询所有表及其占用空间:**

```sql
select SEGMENT_NAME, TABLESPACE_NAME, sum(BYTES / 1024 / 1024) || 'M'
  from dba_extents
 where SEGMENT_TYPE = 'TABLE'
 group by SEGMENT_NAME, TABLESPACE_NAME
```

​	**查询表名及其行数(拥有dba权限)**

```sql
select table_name, num_rows, OWNER
  from dba_tables t
 where t.OWNER = 'BJSOC'
   and num_rows != 0
 order by table_name
```

​	**查询表的一条记录最大会占用多少空间**

```sql
select t2.table_name ,  
        (sum(nvl(t2.data_size , 0 )))||' (B)' as  record_size_of_table1  ,   
         round((sum(nvl(t2.data_size , 0 )))/1024 , 4)||' (K)' as  record_size_of_table2
  from 
   (select 
    t1.TABLE_NAME ,  t1.COLUMN_NAME , t1.DATA_TYPE ,
    case 
      when   t1.DATA_TYPE = 'NUMBER' then    floor((nvl(t1.DATA_PRECISION , 0 )+1)/2)+2
      when   t1.DATA_TYPE = 'DATE'   then  7 
      else   t1.DATA_LENGTH  
    end  as  data_size 
   from user_tab_columns  t1 ) t2  
 group by t2.table_name  order by t2.table_name 
```

#### 导入和导出

- exp导出数据(dmp格式)

```shell
exp scott/tiger@orcl file=D:\database.dmp;
```

- imp导入数据

```shell
imp scott/tiger@orcl file=D:\database.dmp;
```

> 会出现的问题:
>
> 1.导入的用户权限不够,导出用户有DBA权限,解决方案:增加权限grant dba to 用户名;
>
> 2.必须指出需要导入多少数据
>
> imp scott/tiger@orcl full=y file=D:\database.dmp; --全部数据
>
> imp scott/tiger@orcl file=D:\database.dmp tables=(tb1,tb2);  --某些表内容
>
> 3.导入数据已存在
>
> imp scott/tiger@orcl  ignore=y  file=D:\database.dmp;  --忽略存在内容



#### system密码重置(对oracle服务器有管理员权限)

- `sqlplus /nolog` 进入sql命令行
- `conn / as sysdba` 以sysdba登陆
- `alter user system identified by password;` 重置密码为password

#### wm_concat函数

可以把列值以','号分隔起来并显示成一行

```sql
select wm_concat(name) from test;
select replace(wm_concat(name),',','|') from test
```

### mysql

#### 查询版本和位数

```sql
select version();
show variables like '%version_%'

show databases; -- 查看所有数据库
select database(); --查看当前数据库
```
#### 外键的级联删除

```sql
alter table user_image_results_assoc add constraint FK_Reference_1 foreign key (resultid)
      references user_image_results (resultid) on delete restrict on update restrict;
/*restrict是限制的意思*/
/*CASCADE 是级联的意思*/
所以要将上面的改为cascade
```

#### 删除的三种方法

```sql
/*删除内容和定义，释放空间*/
drop table if exists legal_holiday;
drop table tb;

/*删除内容、释放空间但不删除定义，无法级联删除，受外键影响*/
truncate table tb;

/*删除内容不删除定义，不释放空间，可以级联删除，效率底一行行删除*/
delete from tb
```

#### 导出导入

- 导出整个数据库 

　　mysqldump -u用户名 -p密码  数据库名 > 导出的文件名 
　　C:\Users\jack> mysqldump -uroot -pmysql sva_rec  > e:\sva_rec.sql 

- 导出一个表，包括表结构和数据 

　　mysqldump -u用户名 -p 密码  数据库名 表名> 导出的文件名 
　　C:\Users\jack> mysqldump -uroot -pmysql sva_rec date_rec_drv> e:\date_rec_drv.sql 

- 导出一个数据库结构 

　　C:\Users\jack> mysqldump -uroot -pmysql -d sva_rec > e:\sva_rec.sql 

- 导出一个表，只有表结构 

　　mysqldump -u用户名 -p 密码 -d数据库名  表名> 导出的文件名 
　　C:\Users\jack> mysqldump -uroot -pmysql -d sva_rec date_rec_drv> e:\date_rec_drv.sql 

- 导入数据库 

　　常用source 命令 
　　进入mysql数据库控制台， 
　　如mysql -u root -p 
　　mysql>use 数据库 
　　然后使用source命令，后面参数为脚本文件(如这里用到的.sql) 
　　mysql>source d:wcnc_db.sql

### jquery

#### 回车键登陆

```javascript
document.onkeydown = function(e) {
    var ev = document.all ? window.event : e;
     if(ev.keyCode==13) {
          if (!$('#btsubmit').prop('disabled'))
                loginsubmit();
     }
}
```

#### prop attr css

```javascript
$('#btsubmit').prop('disabled')			//判断元素是否disabled，是的话返回true

$('#btsubmit').attr('disabled',false);	//设置元素的属性值

$('#errorinfo').css('display','none');	//设置元素的CSS属性值
$("p").css("background-color");			//返回元素的CSS属性值
```

#### animated重复动画

```javascript
$('#errorinfo').addClass( 'animated shake').one(
    'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', function() {
        $(this ).removeClass('animated shake');
});
//.one用来判断动画结束
```

#### 实时监控文本框输入值

- oninput 是 HTML5 的标准事件，检测 textarea, input:text, input:password 和 input:search 发生的内容变化，在内容修改后立即被触发
- onchange 事件需要失去焦点才触发。
- oninput 事件在 IE9 以下版本不支持，需要使用 IE 特有的 onpropertychange 事件替代

```html
<head>
    <script type="text/javascript">
    // Firefox, Google Chrome, Opera, Safari, Internet Explorer from version 9
        function OnInput (event) {
            alert ("The new content: " + event.target.value);
        }
    // Internet Explorer
        function OnPropChanged (event) {
            if (event.propertyName.toLowerCase () == "value") {
                alert ("The new content: " + event.srcElement.value);
            }
        }
    </script>
</head>
<body>
    Please modify the contents of the text field.
    <input type="text" oninput="OnInput (event)" onpropertychange="OnPropChanged (event)" value="Text field" />
</body>
```

- 使用jquery库的写法

```javascript
$('textarea').bind('oninput propertychange', function() {
    $('.msg').html($(this).val().length + ' characters');
});
```

#### json和xml解析与转换

- JSON

  - json直接使用.解析：data.logincode == '1'


-   json对象转换为字符串 JSON.stringify(data);
  - 字符串转换为json对象 JSON.parse(jsonstr);

- xml

  - 解析：var account = $(data).find('Account').text();

  - xml对象转字符串

    ```javascript
    (new XMLSerializer()).serializeToString(xmlData); //火狐
    xmlData.xml;  //IE
    ```

  - 字符串转xml对象

    ```javascript
    //FF   
     if (document.implementation.createDocument) {   
             var parser = new DOMParser()   
             xmlDoc = parser.parseFromString(xmlString, "application/xml")   
    //IE   
     } else if (window.ActiveXObject) {   
             xmlDoc = new ActiveXObject("Microsoft.XMLDOM")   
             xmlDoc.async="false"  
             xmlDoc.loadXML(xmlString)   
     } 
    ```

#### 遍历来实现批量修改

```javascript
$("#strategySet").find("select").each(function (i){
    var DomId =  $(this).attr("name");
}
```

#### 字符串空格处理

```javascript
str=$.trim(str);
```

#### append() 和 prepend()

```javascript
$("p").append(" <b>Hello world!</b>");   //在被选元素的后面插入指定内容
$("p").prepend("<b>Hello world!</b>");	 //在被选元素的开头插入指定内容
```

### HTML

#### 手机自适应以及禁止缩放

```html
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
```

### CSS

#### 两个DIV并排，且第一个居中

```html
<style type="text/css">
    * {margin:0px; padding:0px;}
    .box {position:absolute; top:50%; left:50%; width:200px; height:100px; margin-left:-50px; margin-top:-50px;}
    .div1 {width:100px; height:100px; background:#ccc; float:left;}
</style>
</head>
<body>
    <div class="box">
        <div class="div1"/>
        <div class="div1"/>
    </div>
</body>
```

#### 判断手机方向

```css
/*判断是否竖屏*/
@media screen and (orientation:portrait) {
    .speedcenter{width:100%}
    .mspeed{left:50%}
}
/*判断是否横屏*/
@media screen and (orientation:landscape) {
    .speedcenter{width:50%}
    .mspeed{left:65%;top:50%}
}
```

#### CSS属性选择器

- 简易属性选择器

  ```css
  h1[class]{color:silver;}			/*作用于任何带class的h1元素*/
  img[alt]{color:silver;}				/*作用于任何带有alt属性的img元素*/
  a[href][title]{font-weight:bold;}	/*作用于同时带href和title属性的a元素*/
  ```

- 精确属性值选择器

  ```css
  h1#logo 等同于 h1[id="logo"]  /*不同于简易选择器，在其基础上添加更精准信息*/
  a[title="W3CHome"]{font-size:200%;} 将会作用于 <a href="http://www.mb5u.com/"title="mb5uHome"></a>
  ```

- 部分属性值选择器

  ```css
  <p class="urgentwarning">Whenhandlingplutonium,oidtheformationofacriticalmass.</p> 
  p[class~="warning"]{font-weight:bold;}  和p[class~="urgent"]{font-weight:bold;} 都会匹配上面的p
  /*比如你要样式化插图，其title中都含字符串”Figure”，如title="Figure5"，则你可以使用img[title~="Figure"]。*/
  ```

- 非凡属性选择器

  ```css
  [lang|="en"]{color:white;}
  这条规则将会选择属性lang的值en或者en-打头的元素
  可以匹配<h1 lang="en">Hello!</h1>、<p lang="en-us">Greetings!</p>和<div lang="en-au">G'day!</div>
  而不匹配<p lang="fr">Bonjour!</p>和<h3 lang="cy-en">Jrooana!</h3>。
  ```

### Spring

http://repo.springsource.org/libs-release-local/org/springframework/spring/ 

> 接口就是为了解耦。。。今后的扩展与维护。。。与spring没有必然联系
> 至于spring 里面的配置，注入未必要接口，只要这个bean存在就行了。
> 但这样，spring效果就大在降低了。。。
> 另外接口并非只是在spring框架中才有解耦作用
> 详细的，网上查一下接口编程之类的信息。。。

- spring 管理bean 就是实例 默认以单例管理

#### IOC 控制反转

- 依赖注入

  - 属性注入；

    ```xml
    <bean id="people2" class="com.java1234.entity.People">
    	<property name="id" value="1"></property>
    	<property name="name" value="张三"></property>
    	<property name="age" value="11"></property>
    </bean>
    ```

  - 构造函数注入；(通过类型；通过索引；联合使用)

    ```xml
    <bean id="people3" class="com.java1234.entity.People">
    	<constructor-arg type="int" value="2"></constructor-arg>
    	<constructor-arg type="String" value="李四"></constructor-arg>
    	<constructor-arg type="int" value="22"></constructor-arg>
    </bean>
    ```

  - 工厂方法注入；(非静态工厂，静态工厂)

    ```xml
    <bean id="peopleFactory" class="com.java1234.factory.PeopleFactory"></bean>

    <bean id="people7" factory-bean="peopleFactory" factory-method="createPeople"></bean>

    <!--PeopleFactory2为静态类-->
    <bean id="people8" class="com.java1234.factory.PeopleFactory2" factory-method="createPeople"></bean>
    ```

  - 泛型依赖注入；(Spring4 整合 Hibernate4 的时候顺带讲)

- 注入参数

  - 基本类型值；

  - 注入 bean；

  - 内部 bean；

    ```xml
    <bean id="people3" class="com.java1234.entity.People">
    	<property name="id" value="1"></property>
    	<property name="name" value="张三"></property>
    	<property name="age" value="11"></property>
    	<property name="dog">
    		<bean class="com.java1234.entity.Dog">
    			<property name="name" value="Tom"></property>
    		</bean>
    	</property>
    </bean>
    ```

  - null 值；

    ```xml
    <bean id="people4" class="com.java1234.entity.People">
    	<property name="id" value="1"></property>
    	<property name="name" value="张三"></property>
    	<property name="age" value="11"></property>
    	<property name="dog">
    		<null></null>
    	</property>
    </bean>
    ```

  - 级联属性；（需要dog类有set方法）

    ```xml
    <bean id="people5" class="com.java1234.entity.People">
    	<property name="id" value="1"/>
    	<property name="name" value="张三"/>
    	<property name="age" value="11"/>
    	<property name="dog.name" value="Jack2"/>
    </bean>
    ```

  - 集合类型属性； 

    ```xml
    <bean id="people6" class="com.java1234.entity.People">
    	<property name="id" value="1"></property>
    	<property name="name" value="张三"></property>
    	<property name="age" value="11"></property>
    	<property name="dog" ref="dog1"></property>
    	<property name="hobbies">
    		<list>
    			<value>唱歌</value>
    			<value>跳舞</value>
    		</list>
    	</property>
    	<property name="loves">
    		<set>
    			<value>唱歌2</value>
    			<value>跳舞2</value>
    		</set>
    	</property>
    	<property name="works">
    		<map>
    			<entry>
    				<key><value>上午</value></key>
    				<value>写代码</value>
    			</entry>
    			<entry>
    				<key><value>下午</value></key>
    				<value>测试代码</value>
    			</entry>
    		</map>
    	</property>
    	<property name="addresses">
    		<props>
    			<prop key="address1">aaaaa</prop>
    			<prop key="address2">bbbbb</prop>
    		</props>
    	</property>
    </bean>
    ```

- Spring 自动装配 （配置 default-autowire 属性 ）

  - byName：通过名称进行自动匹配；

  - byType：根据类型进行自动匹配；

  - constructor：和 byType 类似，只不过它是根据构造方法注入而言的，根据类型，自动注入； 

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd"
            default-autowire="constructor">
    	
    	<bean id="dog2" class="com.java1234.entity.Dog">
    		<property name="name" value="Jack"></property>
    	</bean>
    	
    	<bean id="people1" class="com.java1234.entity.People">
    		<property name="id" value="1"></property>
    		<property name="name" value="张三"></property>
    		<property name="age" value="11"></property>
    	</bean>
    </beans>
    ```

- 方法注入 （lookup-method）

  ```xml
  <bean id="people1" class="com.java1234.entity.People">
    <property name="id" value="1"></property>
    <property name="name" value="张三"></property>
    <property name="age" value="11"></property>
    <lookup-method name="getDog" bean="dog"/>
  </bean>
  ```

- bean之间的关系

  - 继承（parent）

  - 依赖（depends-on）

    ```xml
    <bean id="abstractPeople" class="com.java1234.entity.People" abstract="true">
    	<property name="className" value="高三5班"/>
    	<property name="age" value="19"/>
    </bean>

    <bean id="zhangsan" parent="abstractPeople" depends-on="autority">
    	<property name="id" value="1"/>
    	<property name="name" value="张三"/>
    </bean>
    ```

  - 引用（ref）

    ```xml
    <bean id="dog1" class="com.java1234.entity.Dog">
    	<property name="name" value="Jack"></property>
    </bean>

    <bean id="people2" class="com.java1234.entity.People">
    	<property name="id" value="1"></property>
    	<property name="name" value="张三"></property>
    	<property name="age" value="11"></property>
    	<property name="dog" ref="dog1"></property>
    </bean>
    ```

- bean作用范围

  - 默认singleton （单例）

  - prototype ：每次返回一个新的实例

  - request：每次http请求都会创建一个新的实例

  - session 同一个 HTTP Session 共享一个 Bean；

  - global session 同一个全局 Session 共享一个 Bean，一般用于 Portlet 应用环境；

  - application 同一个 Application 共享一个 Bean； 

    ```xml
    <bean id="dog" class="com.java1234.entity.Dog" scope="singleton">
    	<property name="name" value="jack"></property>
    </bean>
    ```

#### AOP 面向切面 

- 定义一个类为aop(也可以叫做事务通知)

  - 定义切点（即寻找需要切入的方法）

  - 定义通知方式（即这个类中的一个方法），引用切点

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop.xsd">
    	
    	<bean id="studentServiceAspect" class="com.java1234.advice.StudentServiceAspect"></bean>

    	<aop:config>
    		<aop:aspect id="studentServiceAspect" ref="studentServiceAspect">
    			<aop:pointcut expression="execution(* com.java1234.service.*.*(..))" id="businessService"/>
    			<aop:before method="doBefore" pointcut-ref="businessService"/>
    			<aop:after method="doAfter" pointcut-ref="businessService"/>
    			<aop:around method="doAround" pointcut-ref="businessService"/>
    			<aop:after-returning method="doAfterReturning" pointcut-ref="businessService"/>
    			<aop:after-throwing method="doAfterThrowing" pointcut-ref="businessService" throwing="ex"/>
    		</aop:aspect> 
    	</aop:config>
    </beans>
    ```

- 通知类型

  - 前置通知；
  - 后置通知；
  - 环绕通知；
  - 返回通知；
  - 异常通知； 

#### DAO支持

- 使用Apache dbcp的数据库连接池

  > 现在常用的开源数据连接池主要有c3p0、dbcp和proxool三种
  >
  > hibernate开发组推荐使用c3p0; 
  > spring开发组推荐使用dbcp(dbcp连接池有weblogic连接池同样的问题，就是强行关闭连接或数据库重启后，无法reconnect，告诉连接被重置，这个设置可以解决); 
  > hibernate in action推荐使用c3p0和proxool;

  ```xml
  <!-- 配置dbcp数据源 -->
  <bean id="dataSource2" destroy-method="close" class="org.apache.commons.dbcp.BasicDataSource">
  	<property name="driverClassName" value="${jdbc.driverClassName}"/>
  	<property name="url" value="${jdbc.url}"/>
  	<property name="username" value="${jdbc.username}"/>
  	<property name="password" value="${jdbc.password}"/>
  	<!-- 池启动时创建的连接数量 -->
  	<property name="initialSize" value="5"/>
  	<!-- 同一时间可以从池分配的最多连接数量。设置为0时表示无限制。 -->
  	<property name="maxActive" value="30"/>
  	<!-- 池里不会被释放的最多空闲连接数量。设置为0时表示无限制。 -->
  	<property name="maxIdle" value="20"/>
  	<!-- 在不新建连接的条件下，池中保持空闲的最少连接数。 -->
  	<property name="minIdle" value="3"/>
  	<!-- 设置自动回收超时连接 -->  
  	<property name="removeAbandoned" value="true" />
  	<!-- 自动回收超时时间(以秒数为单位) -->  
  	<property name="removeAbandonedTimeout" value="200"/>
  	<!-- 设置在自动回收超时连接的时候打印连接的超时错误  --> 
  	<property name="logAbandoned" value="true"/>
  	<!-- 等待超时以毫秒为单位，在抛出异常之前，池等待连接被回收的最长时间（当没有可用连接时）。设置为-1表示无限等待。  -->  
  	<property name="maxWait" value="100"/>  
  </bean>

  <!-- 配置c3p0数据源 -->
  <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close">
  	<property name="jdbcUrl" value="${jdbc.url}" />
  	<property name="driverClass" value="${jdbc.driverClassName}" />
  	<property name="user" value="${jdbc.username}" />
  	<property name="password" value="${jdbc.password}" />
  	<!--连接池中保留的最大连接数。Default: 15 -->
  	<property name="maxPoolSize" value="100" />
  	<!--连接池中保留的最小连接数。-->
  	<property name="minPoolSize" value="1" />
  	<!--初始化时获取的连接数，取值应在minPoolSize与maxPoolSize之间。Default: 3 -->
  	<property name="initialPoolSize" value="10" />
  	<!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 -->
  	<property name="maxIdleTime" value="30" />
  	<!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 -->
  	<property name="acquireIncrement" value="5" />
  	<!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements
            属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。
            如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0-->
  	<property name="maxStatements" value="0" />

  	<!--每60秒检查所有连接池中的空闲连接。Default: 0 -->
  	<property name="idleConnectionTestPeriod" value="60" />

  	<!--定义在从数据库获取新连接失败后重复尝试的次数。Default: 30 -->
  	<property name="acquireRetryAttempts" value="30" />

  	<!--获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效
            保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试
            获取连接失败后该数据源将申明已断开并永久关闭。Default: false-->
  	<property name="breakAfterAcquireFailure" value="true" />

  	<!--因性能消耗大请只在需要的时候使用它。如果设为true那么在每个connection提交的
            时候都将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable
            等方法来提升连接测试的性能。Default: false -->
  	<property name="testConnectionOnCheckout"  value="false" />        
  </bean>
  ```

- 配置完连接池

  - 使用jbdcTemlate

    - 配置xml

      ```xml
      <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
      	<property name="dataSource" ref="dataSource"></property>
      </bean>
      <!--在dao实现类中注入jdbcTemplate-->
      <bean id="studentDao" class="com.java1234.dao.impl.StudentDaoImpl">
      	<property name="jdbcTemplate" ref="jdbcTemplate"></property>
      </bean> 
      <!--在Service层注入dao-->
      <bean id="studentService" class="com.java1234.service.impl.StudentServiceImpl">
      	<property name="studentDao" ref="studentDao"></property>
      </bean> 
      ```

    - dao实现

      ```java
      //增删改
      String sql="delete from t_student where id=?";
      Object []params=new Object[]{id};
      return jdbcTemplate.update(sql,params);

      //查
      public List<Student> findStudents() {
      	String sql="select * from t_student";
      	final List<Student> studentList=new ArrayList<Student>();
      	jdbcTemplate.query(sql, new RowCallbackHandler(){

      		@Override
      		public void processRow(ResultSet rs) throws SQLException {
      			Student student=new Student();
      			student.setId(rs.getInt("id"));
      			student.setName(rs.getString("name"));
      			student.setAge(rs.getInt("age"));
      			studentList.add(student);
      		}
      		
      	});
      	return studentList;
      }
      ```

  - 使用NamedParameterJdbcTemplate，支持属性名称

    - 配置xml，以构造注入

      ```xml
      <bean id="namedParameterJdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">
          	<constructor-arg ref="dataSource"></constructor-arg></bean>
      ```

    - dao实现

      ```java
      public int addStudent(Student student) {
      	String sql="insert into t_student values(null,:name,:age)";
      	MapSqlParameterSource sps=new MapSqlParameterSource();
      	sps.addValue("name", student.getName());
      	sps.addValue("age", student.getAge());
      	return namedParameterJdbcTemplate.update(sql,sps);
      }

      public List<Student> findStudents() {
      	String sql="select * from t_student";
      	final List<Student> studentList=new ArrayList<Student>();
      	namedParameterJdbcTemplate.query(sql, new RowCallbackHandler(){

      		@Override
      		public void processRow(ResultSet rs) throws SQLException {
      			Student student=new Student();
      			student.setId(rs.getInt("id"));
      			student.setName(rs.getString("name"));
      			student.setAge(rs.getInt("age"));
      			studentList.add(student);
      		}
      		
      	});
      	return studentList;
      }
      ```

#### 对jdbc支持

- dao实现类继承于JdbcDaoSupport

  - JdbcDaoSupport里面包含jdbcTemplate（所以dao类中的jdbcTemplate可以删除）

    ```java
    //private JdbcTemplate jdbcTemplate;

    /*public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
    	this.jdbcTemplate = jdbcTemplate;
    }*/
    ```

  - JdbcDaoSupport需要被注入dataSource，修改配置文件

    ```xml
    <!--<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    	<property name="dataSource" ref="dataSource"></property>
    </bean>-->
    <!--在dao实现类中注入dataSource-->
    <bean id="studentDao" class="com.java1234.dao.impl.StudentDaoImpl">
    	<property name="dataSource" ref="dataSource"></property>
    </bean> 
    <!--在Service层注入dao-->
    <bean id="studentService" class="com.java1234.service.impl.StudentServiceImpl">
    	<property name="studentDao" ref="studentDao"></property>
    ```

#### 对事务的支持

- 编程式事务管理

  - Spring 提供的事务模版类：org.springframework.transaction.support.TransactionTemplate

  - 事务管理器：org.springframework.jdbc.datasource.DataSourceTransactionManager

  - xml配置

    ```xml
    <!-- jdbc事务管理器 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    	<property name="dataSource" ref="dataSource"></property>
    </bean>

    <bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
    	<property name="transactionManager" ref="transactionManager"></property>
    </bean>

    <bean id="bankService" class="com.java1234.service.impl.BankServiceImpl">
    	<property name="bankDao" ref="bankDao"></property>
    	<property name="transactionTemplate" ref="transactionTemplate"></property>
    </bean> 
    ```

  - service层增加事务实现

    ```java
    private TransactionTemplate transactionTemplate;

    public void transferAccounts(final int count, final int userIdA, final int userIdB) {
    	// TODO Auto-generated method stub
    	transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    		
    		@Override
    		protected void doInTransactionWithoutResult(TransactionStatus arg0) {
    			// TODO Auto-generated method stub
    			bankDao.outMoney(count, userIdA);
    			bankDao.inMoney(count, userIdB);				
    		}
    	});
    }
    ```

- 声明式事务管理（减少事务管理侵入业务代码）

  - 使用xml配置声明式事务

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:tx="http://www.springframework.org/schema/tx"
        xsi:schemaLocation="http://www.springframework.org/schema/tx
            http://www.springframework.org/schema/tx/spring-tx.xsd">
            
    	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
            <property name="driverClassName" value="${jdbc.driverClassName}"/>
            <property name="url" value="${jdbc.url}"/>
            <property name="username" value="${jdbc.username}"/>
            <property name="password" value="${jdbc.password}"/>
        </bean>
      
      	<context:property-placeholder location="jdbc.properties"/>
        
        <!-- jdbc事务管理器 -->
        <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        	<property name="dataSource" ref="dataSource"></property>
        </bean>
        
        <!-- 配置事务通知，包含事务传播配置 -->
        <tx:advice id="txAdvice" transaction-manager="transactionManager">
        	<tx:attributes>  
                <tx:method name="insert*" propagation="REQUIRED" />  
                <tx:method name="update*" propagation="REQUIRED" />  
                <tx:method name="edit*" propagation="REQUIRED" />  
                <tx:method name="save*" propagation="REQUIRED" />  
                <tx:method name="add*" propagation="REQUIRED" />  
                <tx:method name="new*" propagation="REQUIRED" />  
                <tx:method name="set*" propagation="REQUIRED" />  
                <tx:method name="remove*" propagation="REQUIRED" />  
                <tx:method name="delete*" propagation="REQUIRED" />  
                <tx:method name="change*" propagation="REQUIRED" />  
                <tx:method name="get*" propagation="REQUIRED" read-only="true" />  
                <tx:method name="find*" propagation="REQUIRED" read-only="true" />  
                <tx:method name="load*" propagation="REQUIRED" read-only="true" />  
                <tx:method name="*" propagation="REQUIRED" read-only="true" />  
            </tx:attributes>  
        </tx:advice>
        
        <!-- 配置事务切面 -->
        <aop:config>
        	<!-- 配置切点 -->
        	<aop:pointcut id="serviceMethod" expression="execution(* com.java1234.service.*.*(..))" />
        	<!-- 配置事务通知 -->
        	<aop:advisor advice-ref="txAdvice" pointcut-ref="serviceMethod"/>
        </aop:config>
    </beans>
    ```

  - 使用注解配置声明式事务（@Transactional）

    ```xml
    <!-- jdbc事务管理器 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    	<property name="dataSource" ref="dataSource"></property>
    </bean>

    <tx:annotation-driven transaction-manager="transactionManager"/>
    ```


#### 使用Spring

- java代码直接引用

  - 配置

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd">

    	<bean id="helloWorld" class="com.java1234.test.HelloWorld"></bean>

      
    </beans>
    ```

  - 代码

      ```java
      public static void main(String[] args) {
      	ApplicationContext ac=new ClassPathXmlApplicationContext("beans.xml");
      	HelloWorld helloWorld=(HelloWorld)ac.getBean("helloWorld");
      	helloWorld.say();
      }
      ```


- web.xml

  ```xml
  <!-- 添加对spring的支持 -->  
  <context-param>  
  	<param-name>contextConfigLocation</param-name>  
  	<param-value>classpath:applicationContext.xml</param-value>  
  </context-param>  

  <!-- 定义Spring监听器，加载Spring  -->
  <listener>  
  	<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  
  </listener> 
  ```

### xml

- 使用<![CDATA[文本内容]]>来处理包含的<>&等符号，不能包含]]>(这是结束标签)
- 使用


```xml
&lt;  	代替 	<
&gt;  	代替 	>
&amp; 	代替	&
&quot;  代替  "             
&apos;  代替  '     
```


## 工具篇

### Tomcat

#### 加入密码

tomcat-users.xml

```xml
<tomcat-users></tomcat-users>之间加上这一句
<user name="admin" password="admin123" roles="manager-gui"/>
```

#### 服务端支持utf-8

server.xml

```xml
<Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" URIEncoding="UTF-8"/>
```

### Soapui

#### 注意

- 输入的xml要有 <![CDATA[xml文本]]>

#### soapui技术

![socket](https://raw.githubusercontent.com/jayypc/notes/master/images/socket.png)

### myeclipse

#### 新建wsdl

右键
-> new -> other -> web services -> Web Service Client ->粘贴wsdl地址 ->选择要生成的地址
-> 删除多余文件

#### 增强补全功能

Eclipse -> Window -> Perferences -> Java -> Editor -> Content Assist下

**Auto activation triggers for Java**里的.改为

```
".abcdefghijklmnopqrstuvwsyzABCDEFGHIJKLMNOPQRSTUVWSYZ_"
```

如果版本比较低，不能直接修改的话，就导出配置文件，然后修改配置文件，最后再导入配置文件。

#### myeclipse低版本去除空格和=号补全

- 查看myeclipse对应eclipse版本

  安装目录MyEclipse 6.6/eclipse/readme下的readme_eclipse.html中的版本号

- 下载eclipse源码

  http://archive.eclipse.org/eclipse/downloads/

- 修改org.eclipse.jface.text包替换到eclipse/plugins

  - src/org/eclipse/jface/text/contentassist/CompletionProposalPopup.java

  ```java
  char[] triggers = t.getTriggerCharacter(); 
  if (contains(triggers, key))
  改为
  if(key != '=' && key != 0x20 &&contains(triggers,key)){ .........}
  ```

### PowerDesigner

> 先将现实世界中的客观对象抽象为实体(Entity)和联系(Relationship),它并不依赖于具体的计算机系统或某个DBMS系统，这种模型就是我们所说的**概念数据模型**CDM
>
> 然后再将CDM转换为计算机上某个DBMS所支持的数据模型，这样的模型就是**物理数据模型**,即PDM。

- 左侧结构：

  - Workspace
    - 模型（assetmanage）
      - 默认图（asset）
      - 图中包含表（tables）
      - 图中包含关系（references）

- 增加表注释

  双击表进入设置，点击标签页Columns，单击customize columns and filter（自定义列和过滤器），勾选Commont

- Columns的各个属性

  - Name是PowerDesigner的展示内容
  - Code是具体的表属性
  - Comment是属性注释
  - Data Type是数据类型
  - Length是数据长度（但有些类型如Date是没有长度的）
  - P是主键选项
  - M是非空项选项
  - F是外键选项


- 新建物理数据对象模型

  Physical Data Model > Physical Diagram

- 业务流程图

  Business Process Model > Business Process Diagram

- 业务层次分析图

  Business Process Model > Process Hierarchy Diagram