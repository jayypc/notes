## 实践笔记

### sql

#### 判断是否为空

```sql
exch is null 
```
#### case语句加正则匹配所有数字

```sql
case
	when REGEXP_LIKE(netcartrate,'(^[+-]?\d{0,}\.?\d{0,}$)') then
		netcartrate || 'M'
	else
		netcartrate
	end 
		netcartrate

--简单Case函数
CASE sex
WHEN '1' THEN '男'
WHEN '2' THEN '女'
ELSE '其他' END
--Case搜索函数
CASE WHEN sex = '1' THEN '男'
WHEN sex = '2' THEN '女'
ELSE '其他' END
--正则表达式
^ 匹配输入字符串的开始位置
[+-] 匹配指定范围内的任意字符
? 匹配0或1个正好在它之前的那个字符
\d 匹配一个数字字符
{n,} n是一个非负整数。至少匹配前面的n次
$ 匹配输入字符串的结束位置
```
#### 更新语句

```sql
UPDATE temp_userid t
SET t.ctime = (
		SELECT max(b.btime)
		FROM vi_speed_info b
		WHERE b.userid = t.userid
		)
--MAX 函数返回一列中的最大值
```
#### OVER()函数 和 更新两个字段

```sql
UPDATE test_for_search t
SET (
		t.stime
		,t.responserate
		) = (
		SELECT a.stime,a.responserate
		FROM (
			SELECT userid,responserate,stime
			FROM (
				SELECT b.userid
					,b.responserate
					,b.stime
					,row_number() OVER (PARTITION BY b.userid ORDER BY b.stime) AS ind
				FROM v_speed_info_bday b
					,test_for_search t
				WHERE b.userid = t.userid
					AND b.stime BETWEEN to_date('2016-03-10 000000', 'yyyy-mm-dd hh24miss')
						AND to_date('2016-03-10 235959', 'yyyy-mm-dd hh24miss')
				GROUP BY b.userid,b.responserate,b.stime
				)
			WHERE ind = 1
			) a
		WHERE a.userid = t.userid
		)
--分析函数OVER(PARTITION BY)
ROW_NUMBER()返回结果集分区内行的序列号，每个分区的第一行从 1 开始

select decode(grouping(http_url), 1, '综合平均', http_url) http_url,
       avg(t.fscreen_res_times),
       avg(t.homepage_res_times),
       avg(t.homepage_dw_speed),
       avg(t.tcp_delay_times),
       avg(t.http_delay_times),
       avg(t.dns_delay_times),
       avg(t.access_succ_rate),
       avg(t.qoe_value)
  from app_qoe_http_info t
 where stime between to_date('2015-12-03 000000', 'yyyy-mm-dd hh24miss') and
       to_date('2015-12-03 171717', 'yyyy-mm-dd hh24miss')
   and t.band_width in
       (select rate_id from nettype_info where bandrate = '100M')
   and substr(t.citycd, 0, 2) = '08'
 group by rollup(http_url)

--聚合函数
--AVG	返回指定组中的平均值，空值被忽略
select  prd_no,avg(qty) from sales group by prd_no

--COUNT	返回指定组中项目的数量
select  count(prd_no) from sales

--COUNT_BIG  返回指定组中的项目数量，与COUNT函数不同的是COUNT_BIG返回bigint值，而COUNT返回的是int值
select  count_big(prd_no) from sales

--MAX	返回指定数据的最大值
select  prd_no,max(qty) from sales group by prd_no

--MIN  	返回指定数据的最小值
select  prd_no,min(qty) from sales group by prd_no

--SUM  	返回指定数据的和，只能用于数字列，空值被忽略
select  prd_no,sum(qty) from sales group by prd_no

--GROUPING  产生一个附加的列，当用CUBE或ROLLUP运算符添加行时，输出值为1.当所添加的行不是由CUBE或ROLLUP产生时，输出值为0
select  prd_no,sum(qty),grouping(prd_no) from sales group by prd_no with rollup

/*BINARY_CHECKSUM  返回对表中的行或表达式列表计算的二进制校验值，用于检测表中行的更改
CHECKSUM_AGG  返回指定数据的校验值，空值被忽略
CHECKSUM  返回在表的行上或在表达式列表上计算的校验值，用于生成哈希索引
STDEV  返回给定表达式中所有值的统计标准偏差
STDEVP  返回给定表达式中的所有值的填充统计标准偏差
VAR  返回给定表达式中所有值的统计方差
VARP  返回给定表达式中所有值的填充的统计方差*/

--ROLLUP()和CUBE()区别
--ROLLUP()生成简单的 GROUP BY 聚合行以及小计行或超聚合行，还生成一个总计行。
SELECT a, b, c, SUM ( <expression> )
FROM T
GROUP BY ROLLUP (a,b,c)
--会为 (a, b, c)、 (a, b) 和 (a) 值的每个唯一组合生成一个带有小计的行,还将计算一个总计行
--CUBE()生成简单的 GROUP BY 聚合行、ROLLUP 超聚合行和交叉表格行
SELECT a, b, c, SUM (<expression>)
FROM T
GROUP BY CUBE (a,b,c)
--会为 (a, b, c)、 (a, b)、 (a, c)、 (b, c)、 (a)、 (b) 和 (c) 值的每个唯一组合生成一个带有小计的行，还会生成一个总计行
```
#### 增加外键

作用是:最直观的作用是**防止非法数据录入**，就是说录入外键数据时必须在它所属的主表中存在相应数据，如果录入空字符或其他数据会报错。从软件工程的角度看，建立数据库的过程，是从建立物理模型开始的。在物理模型中创建了外键，那么在转化成概念模型甚至于生成sql代码时，就会自动生成相应字段，而不用重复定义。

```sql
create table dept	--公司的部门信息
(deptno number(10) not null,
deptname varchar2(30) not null,
constraint pk_dept primary key(deptno));	--主键

create table emp	--员工的基本信息
( empno number(10) not null,
fname varchar2(20) ,
lname varchar2(20) ,
dept number(10) ,
constraint pk_emp primary key(empno));  --主键

--在员工表增加外键关联到部门表,同时增加级联删除(on delete cascade这句话不加也可以)
alter table emp
add constraint fk_emp_dept foreign key(dept) references dept(deptno) on delete cascade;

delete from dept where deptno = 1;
--删除dept中的一条数据，emp中两条数据也被删除了
```
#### substr

取反查的area前两位和area_info关联

```sql
substr(a.area,1,2)=b.soapcode
```

#### 字符串相加 和 判空

NVL2(expr1,expr2,expr3) 功能：如果参数表达式expr1值为NULL，则NVL2()函数返回参数表达式expr3的值；如果参数表达式expr1值不为NULL，则NVL2()函数返回参数表达式expr2的值。

NVL( string1, replace_with) 功能：如果string1为NULL，则NVL函数返回replace_with的值，否则返回string1的值，如果两个参数都为NULL ，则返回NULL。


```sql
cpuusage || '%' cpuusage,

nvl2(cpuusage,cpuusage || '%', 0) cpuusage,
```

#### between

```sql
between to_date('2015-09-23 000000','yyyy-mm-dd hh24miss') 
	and to_date('2015-09-23 175959','yyyy-mm-dd hh24miss')
```

#### decode

将查询结果翻译成其他值

```sql
decode(条件,值1,翻译值1,值2,翻译值2,...值n,翻译值n,缺省值)
```

#### round

ROUND 函数用于把数值字段舍入为指定的小数位数

```sql
round(avg(t.down_speed),2),
```

#### 将表结构导出到word

```sql
SELECT t1.Table_Name AS "表名称",
t3.comments AS "表说明", 
t1.Column_Name AS "字段名称",
t1.Data_Type AS "数据类型",
t1.Data_Length AS "长度",
t1.NullAble AS "是否为空",
t2.Comments AS "字段说明",
t1.Data_Default "默认值"
FROM cols t1 left join user_col_comments t2
on t1.Table_name=t2.Table_name and t1.Column_Name=t2.Column_Name
left join user_tab_comments t3 
on t1.Table_name=t3.Table_name 
WHERE NOT EXISTS ( SELECT t4.Object_Name FROM User_objects t4
WHERE t4.Object_Type='TABLE' 
AND t4.Temporary='Y' 
AND t4.Object_Name=t1.Table_Name )
ORDER BY t1.Table_Name, t1.Column_ID;
```

#### 修改表字段varchar长度

```sql
oracle下这么执行
alter table member modify  phone char(15);
sqlserver下这么执行
alter table member alter column  phone char(15);
```

### java

#### 判断是否是数字的正则表达式

```java
public static boolean isNumeric(String tester) {
        boolean isNumeric=false;
        if(Validators.isNotnull(tester) && Pattern.matches("^(-)?\\d+$", tester)) {
            isNumeric = true;
        }
        return isNumeric;
}
/*
^  代表第一个位置
(-)代表负号, 要匹配圆括号字符，请使用“\(”或“\)”
?  前面的也就是(-)出现零次或者一次
\  在java中代表转义字符,所以要得到正则表达式的\d(代表一个数字),需要\\才能够得到\,然后加个d
+  代表前面的表达式即\d可以出现一次或者多次
$  代表最后一个位置
*/
```

#### Hibernate

**getSession()**

- getSession()只要继承 sessionFactory
- getSession()方法，spring会把最原始的session给你，在使用完之后必须自己调用相应的close方法，而且也不会对声明式事务进行相应的管理，一旦没有及时关闭连接，就会导致数据库连接池的连接数溢出

**getHibernateTemplate()**

- getHibernateTemplate()方法必须继承HibernateDaoSupport

- getHibernateTemplate()方法是经过spring封装的，例如添加相应的声明式事务管理，由spring管理相应的连接。

- HibernateTemplate 提供非常多的常用方法来完成基本的操作，比如通常的增加、删除、修改、查询等操作

  - q void delete(Object entity)：删除指定持久化实例 
  - q deleteAll(Collection entities)：删除集合内全部持久化类实例 
  - q find(String queryString)：根据HQL查询字符串来返回实例集合 
  - q findByNamedQuery(String queryName)：根据命名查询返回实例集合 
  - q get(Class entityClass, Serializable id)：根据主键加载特定持久化类的实例 
  - q save(Object entity)：保存新的实例 
  - q saveOrUpdate(Object entity)：根据实例状态，选择保存或者更新 
  - q update(Object entity)：更新实例的状态，要求entity是持久状态 
  - q setMaxResults(int maxResults)：设置分页的大小

- 有些方法在getHibernateTemplate()并没有提供，这时我们用HibernateCallback 回调的方法管理数据库

  ```java
  //execute是最基础的
  //<Object> Object HibernateTemplate.execute(HibernateCallback<Object> action) throws DataAccessException
  public VulScannerInfo getScannerInfoByScannerId(final Long scannerId) {
    return (VulScannerInfo) getHibernateTemplate().execute(new HibernateCallback<Object>(){
      public Object doInHibernate(Session session)
        throws HibernateException, SQLException {

        //扫描器ID为空，则返回空
        if(scannerId == null){
          return null;
        }

        String hql = "from VulScannerInfo where scannerid = :scannerid and deleted = 0";
  	  //使用hql调用createQuery()方法
        Query query = session.createQuery(hql);
        query.setParameter("scannerid", scannerId);
  	  //确定返回的实例只有一个或者null时 用uniqueResult()方法
        return query.uniqueResult();
      }

    });
  }

  //excuteFind就是execute的结果集判断了一下:HibernateCallback 类型的action必须返回list
  public List<VulRiskTaskResultDetail> getVulTaskResultDetails(final FilterChain chain) {
    return getHibernateTemplate().executeFind(new HibernateCallback<Object>(){
      public Object doInHibernate(Session session) throws HibernateException, SQLException {

        String sql = "select  distinct {t.*} from vul_risk_task_result_detail t ";
        sql += "left join vul_risk_task_detail_history history on history.detailid = t.detailid ";
        if(chain != null){
          sql += chain.toSql();
        }
        //使用sql调用createSQLQuery()方法
        SQLQuery query = session.createSQLQuery(sql);
        setQueryParameter(query, chain);
        query.addEntity("t",VulRiskTaskResultDetail.class);
  	  //查询返回多个值用list()方法
        return query.list();
      }

    });
  }

  //或者使用?来做占位符
  public void paySuccess(Long orderNo) {
    String sql = "update Order  set  status =1  ,  payTime =?  where orderNo =? ";
    getCurrentSession().createQuery(sql).setTimestamp(0 ,new Date()).setLong(1, orderNo).executeUpdate();
  }

  //in语句中可以使用setParameterList()方法
  public Integer updateStatusDiscard(List<Long> rids) {
    String sql = "UPDATE requirement r SET r.status=0,r.updateTime=NOW() WHERE r.id IN (:rids)";
    return getCurrentSession().createSQLQuery(sql).setParameterList("rids", rids).executeUpdate();
  }
  ```

#### struts1

```java
//两种返回方式
return mapping.findForward("main");
return mapping.getInputForward();
```

### linux

#### netstat

用于显示各种网络相关信息

-a (all)显示所有选项，默认不显示LISTEN相关
-t (tcp)仅显示tcp相关选项
-u (udp)仅显示udp相关选项
-n 拒绝显示别名，能显示数字的全部转化成数字。
-l 仅列出有在 Listen (监听) 的服務状态

#### grep

正则匹配命令

-I ：忽略大小写 
-c ：打印匹配的行数 
-l ：从多个文件中查找包含匹配项 
-v ：查找不包含匹配项的行 
-n：打印包含匹配项的行和行标

```shell
$ grep ‘test’ d*
显示所有以d开头的文件中包含 test的行。
$ grep ‘test’ aa bb cc
显示在aa，bb，cc文件中匹配test的行。
$ grep ‘[a-z]\{5\}’ aa
显示所有包含每个字符串至少有5个连续小写字符的字符串的行。
```

#### wc

-c 统计字节数。
-l 统计行数。
-m 统计字符数。这个标志不能与 -c 标志一起使用。
-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。
-L 打印最长行的长度。

```shell
基于上面的三条命令
netstat -na|grep 80|wc -l
查询80端口的监听数目
```
### 